#ifndef HASH_TABLE_HPP
#define HASH_TABLE_HPP

/*
	- When we resize the table, memory addresses of the keys/values will change, which makes pointers to them useless. Do we care about this?
*/
namespace HashTableFuncs
{
//	void print(long a);
//	void print(int a);
//	void print(unsigned long a);
//	void print(unsigned int a);
//	void print(double a);
//	void print(void *a);
//	void print(const char *a);
	unsigned long hash_digest(long Key);
	unsigned long hash_digest(int Key);
	unsigned long hash_digest(unsigned long Key);
	unsigned long hash_digest(unsigned int Key);
	unsigned long hash_digest(double Key);
	unsigned long hash_digest(float Key);
	unsigned long hash_digest(const char *Key);
	unsigned long hash_digest(void *Key);
	bool are_equal(long Key1, long Key2);
	bool are_equal(int Key1, int Key2);
	bool are_equal(unsigned long Key1, unsigned long Key2);
	bool are_equal(unsigned int Key1, unsigned int Key2);
	bool are_equal(double Key1, double Key2);
	bool are_equal(const char *Key1, const char *Key2);
	bool are_equal(void *Key1, void *Key2);

//	template <typename TYPE> unsigned long print(TYPE Key) {printf("should print");}
	template <typename TYPE> unsigned long hash_digest(TYPE Key)
	{
		unsigned long HashDigest = 0;
		unsigned char *Ptr = (unsigned char *)&Key;
		for(int i = 0; i < sizeof(Key); ++i) HashDigest += Ptr[i];
		return HashDigest;
	}
	template <typename TYPE> bool are_equal(TYPE Key1, TYPE Key2)
	{
		bool AreEqual = true;
		unsigned char *Ptr1 = (unsigned char *)&Key1;
		unsigned char *Ptr2 = (unsigned char *)&Key2;
		for(int i = 0; i < sizeof(TYPE); ++i)
		{
			if(Ptr1[i] != Ptr2[i])
			{
				AreEqual = false;
				break;
			}
		}
		return AreEqual;
	}
}

template <typename KEY_TYPE, typename VALUE_TYPE>
struct bucket
{
	bool IsSet;
	KEY_TYPE Key;
	VALUE_TYPE Value;
};

#define NUM_BUCKETS_AVAILABLE_INITIALLY 8
typedef void (userPrintKeyFunc)(const void *Key);
typedef void (userPrintValueFunc)(const void *Value);

template <typename KEY_TYPE, typename VALUE_TYPE>
struct hashTable
{
//	hashTable(int NumBucketsAvailableInitially = 64,
//		userPrintKeyFunc *_UserPrintKeyFunc = 0, userPrintValueFunc *_UserPrintValueFunc = 0);

	hashTable();
	hashTable(int NumBucketsAvailableInitially);
	hashTable(userPrintKeyFunc *_UserPrintKeyFunc, userPrintValueFunc *_UserPrintValueFunc);
	hashTable(int NumBucketsAvailableInitially,
		userPrintKeyFunc *_UserPrintKeyFunc, userPrintValueFunc *_UserPrintValueFunc);

	void put(KEY_TYPE Key, VALUE_TYPE Value);
	bool get(KEY_TYPE Key, VALUE_TYPE *OutValue);
	void remove(KEY_TYPE Key);
	void print();

	private:
	void init(int NumBucketsAvailableInitially,
		userPrintKeyFunc *_UserPrintKeyFunc, userPrintValueFunc *_UserPrintValueFunc);
	void expand_table();

	bucket<KEY_TYPE, VALUE_TYPE> *Buckets;
	int NumOccupiedBuckets;
	int NumTotalBuckets;

	userPrintKeyFunc *UserPrintKeyFunc;
	userPrintValueFunc *UserPrintValueFunc;
};

#include "hash_table_implementation.hpp" // Actual definitions of these method-templates above are here. Because they are not actual function definitions, they need to be included in every compilation unit (cpp-file) that uses them. Actual function definitions are generated by the compiler automatically "under the hood" on an as needed basis. This is my understanding.

#endif


